// // ------------------------------------- MEMORY MANAGER ------------------------------------------------------------------ //
// // Function Number	    Function Name	Arguments	         Return Value
// // GET_FREE_PAGE = 1	Get Free Page	NIL	                 Free Page number
// // RELEASE_PAGE = 2	Release Page	Page Number	         NIL
// // GET_FREE_BLOCK = 3	Get Free Block	NIL	                 Free Block Number or -1
// // RELEASE_BLOCK = 4	Release Block	Block Number, PID	 NIL
// // GET_CODE_PAGE = 5	Get Code Page	Block Number	     Page Number
// // GET_SWAP_BLOCK = 6	Get Swap Block	NIL	                 Block Number

// alias functionNum R1;

// //----- Get Free Page (funNum = 1) -----------------------------------------------------
// // Returns the page number of a free page
// // Called by fork and exec system calls. Also called by exception handler on page fault.

// if( functionNum == 1 ) then

//     //Increment WAIT_MEM_COUNT in system status table
//     [SYSTEM_STATUS_TABLE + 3] = [SYSTEM_STATUS_TABLE + 3] + 1;

//     //While memory is full (MEM_FREE_COUNT will be 0)---- BUSY LOOP
//     while( [SYSTEM_STATUS_TABLE + 2] == 0) do
//         [PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1]*16 + 4] = WAIT_MEM;
//         //call module 5
//         multipush(R1);
//         call SCHEDULER;
//         multipop(R1);
//     endwhile ;

//     //Decrement MEM_FREE_COUNT & WAIT_MEM_COUNT in system status table
//     [SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] - 1;
//     [SYSTEM_STATUS_TABLE + 3] = [SYSTEM_STATUS_TABLE + 3] - 1;

//     //Find a free page using memory free list
//     alias pageIdx R2;
//     pageIdx = 0;
//     while( pageIdx < 128 ) do
//         if( [MEMORY_FREE_LIST + pageIdx] == 0 ) then
//             R0 = pageIdx;
//             break;
//         endif ;
//         pageIdx = pageIdx + 1;
//     endwhile ;

//     [MEMORY_FREE_LIST + pageIdx] = 1;
    
//     return;
// endif;

// // ---- Release Page ---------------------------------------------------------
// if(functionNum == 2) then
//     alias releasePageNum R2;
//     // mem_free_list updated
//     [MEMORY_FREE_LIST + releasePageNum] = [MEMORY_FREE_LIST + releasePageNum] - 1;
//     // If the above page gets to 0, implies one more free page, incr mem_free_cnt in SYSTEM STATUS TABLE
//     if([MEMORY_FREE_LIST + releasePageNum] == 0) then
// 		[SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] + 1;
// 	endif;
//     //STATE field of Processes from WAIT_MEM to READY
//     alias var R3;
//     var = 0;
//     while( var < 16 ) do
//         if( [PROCESS_TABLE + 16*var + 4] ==  WAIT_MEM) then
//             [PROCESS_TABLE + 16*var + 4] = READY;
//         endif ;
//         var = var + 1;
//     endwhile ;
//     // breakpoint;
//     return;
// endif;

// // ---- Get Free Block --------------------------------------------------------------------------------
// // Args: none
// // returns :  A free Block or -1
// if(functionNum == 3) then
//     // Loop through the USER BLOCK Section of DISK FREE LIST 
//     // and find a Free Space and return that index
//     // from DISK_FREE_AREA to DISK_SWAP_AREA - 1
//     alias cnt R4;
//     cnt =  DISK_FREE_AREA;
//     while( cnt < DISK_SWAP_AREA - 1) do
//         if([DISK_FREE_LIST + cnt] == 0) then
//             // free space found
//             [DISK_FREE_LIST + cnt] = 1;
//             R0 = cnt;
//             return;
//         endif;
//         cnt = cnt+1;
//     endwhile;
//     R0 = -1;
//     return;
// endif;

// // ---- Release Block ------------------------------------------------------------
// if(functionNum == 4) then
//     alias BlockNumber R2;
//     [DISK_FREE_LIST + BlockNumber] = [DISK_FREE_LIST + BlockNumber] - 1;
// 	return;
// endif;

// // ---- Get Code Page -------------------------------------------------------------
// if(functionNum == 5) then
//     alias DiskBlockNumber R2;
//     // check Disk Map Table of ALL PROCESSES for the Given Disk Number
//     alias diskEntryCnt R5;
//     alias diskEntry R6;
//     alias diskOffset R7;
//     diskEntryCnt = 0;
//     while(diskEntryCnt <= 15) do
//         diskEntry = DISK_MAP_TABLE + diskEntryCnt*10;
//         diskOffset = 4;
//         while(diskOffset <= 7) do
//             if([diskEntry + diskOffset] == DiskBlockNumber && ([PAGE_TABLE_BASE + 20*diskEntryCnt + 2*diskOffset + 1] == "0100" || [PAGE_TABLE_BASE + 20*diskEntryCnt + 2*diskOffset + 1] == "1100" )) then
//                 R0 = [PAGE_TABLE_BASE + 20*diskEntryCnt + 2*diskOffset];
//                 [MEMORY_FREE_LIST + R0] = [MEMORY_FREE_LIST + R0] + 1;
//                 // print(R0);
//                 return;
//             endif;
//             diskOffset = diskOffset + 1;
//         endwhile;
//         diskEntryCnt = diskEntryCnt + 1;
//     endwhile;

//     // Mem Page Not Found, Call Get Free Page (FunNum=1, Mem Manager)
//     multipush(R1,R2,R5,R6,R7);
// 	R1 = 1;
// 	call MOD_2;
// 	multipop(R1,R2,R5,R6,R7);
//     // Call Disk Load, Args: FunNum, PID, Page Number, Block Number
// 	multipush(R0,R1,R2,R5,R6,R7);
// 	R4 = DiskBlockNumber;
// 	R3 = R0;
//     R2 = [SYSTEM_STATUS_TABLE + 1];
//     R1 = 2;
// 	call MOD_4;
// 	multipop(R0,R1,R2,R5,R6,R7);
//     breakpoint;
//     return;
// endif;

// // ---- Get Swap Block --------------------------------------------------------
// // Args: none
// // returns :  Swap Block Number
// if(functionNum == 6) then
//     // Loop through the SWAP AREA of DISK FREE LIST and 
//     // find a Free Space and return that index
//     // from DISK_SWAP_AREA to DISK_SIZE - 1
//     alias cnt R4;
//     cnt = DISK_SWAP_AREA;
//     while( cnt < DISK_SIZE - 1) do
//         if([DISK_FREE_LIST + cnt] == 0) then
//             // free space found
//             [DISK_FREE_LIST + cnt] = 1;
//             R0 = cnt;
//             return;
//         endif;
//         cnt = cnt+1;
//     endwhile;
//     R0 = -1;
//     return;
// endif;

// // //--------------------------MEMORY MANAGER MODULE---------------------------

// // // R1 contains the function number and R2 contains page num if RELEASE_PAGE

// // if(R1 == GET_FREE_PAGE) then
// // 	backup;
	
// // 	//increment the wait memory count
// // 	[SYSTEM_STATUS_TABLE+3] = [SYSTEM_STATUS_TABLE+3] + 1;
	
// // 	while([SYSTEM_STATUS_TABLE+2]==0) do
// // 		[PROCESS_TABLE+16*[SYSTEM_STATUS_TABLE+1]+4] = WAIT_MEM;
// // 		backup;
// // 		call MOD_5;
// // 		restore;
// // 	endwhile;	
// // 	[SYSTEM_STATUS_TABLE+3] = [SYSTEM_STATUS_TABLE+3]-1;
// // 	[SYSTEM_STATUS_TABLE+2] = [SYSTEM_STATUS_TABLE+2]-1;
// // 	restore;
	
// // 	//find a free page using memory free list
// // 	alias i R0;
// // 	i = 76;
// // 	while(i<MAX_MEM_PAGE) do
// // 		if([MEMORY_FREE_LIST+i]==0) then
// // 			[MEMORY_FREE_LIST+i] = 1;
// // 			break;
// // 		endif;
// // 		i = i + 1;
// // 	endwhile;
// // 	//print i;	
// // 	return;
// // endif;

// // if(R1 == RELEASE_PAGE) then
// // 	backup;
		
// // 	alias page_num R2;
// // 	[MEMORY_FREE_LIST + page_num] = [MEMORY_FREE_LIST + page_num] - 1;
	
// // 	//if this page is not used by anyone	
// // 	if([MEMORY_FREE_LIST + page_num] == 0) then
// // 		//increment the memory free count
// // 		[SYSTEM_STATUS_TABLE+2] = [SYSTEM_STATUS_TABLE+2]+1;

// // 		//update the status of processes waiting for memory
// // 		alias i R3;
// // 		i = 0;
	
// // 		while(i<16) do
// // 			if([PROCESS_TABLE+16*i+4] == WAIT_MEM) then
// // 				[PROCESS_TABLE+16*i+4] = READY;
// // 			endif;
// // 			i = i + 1;
// // 		endwhile;

// // 	endif;
	
// // 	restore;			
// // 	return;
// // endif;


// // if(R1 == GET_CODE_PAGE) then	//R2 contains block number to be loaded
// // 	//check the disk map table of all processes for this block
	
// // 	//backup;
// // 	alias Block_num R2;
// // 	alias Disk_Table R3;
// // 	alias i R4;
// // 	alias block R5;
// // 	alias page_num R0;
// // 	i = 0;
	
// // 	while(i<16) do
// // 		Disk_Table = DISK_MAP_TABLE+10*i; //10 entries for a process
// // 		block = 0;
		
// // 		while(block<4) do
// // 			if([Disk_Table+4+block] == Block_num && [PAGE_TABLE_BASE+20*i+2*(block+4)]!=-1) then
// // 				page_num = [PAGE_TABLE_BASE+20*i+2*(block+4)];
// // 				[MEMORY_FREE_LIST+page_num] = [MEMORY_FREE_LIST+page_num] + 1;
// // 				return;
// // 			endif;
// // 			block = block + 1;
// // 		endwhile;
// // 		i = i + 1;
// // 	endwhile;
	
// // 	//code page is not in memory
// // 	R1 = GET_FREE_PAGE;
// // 	call MOD_2;
		
// // 	R1 = DISK_LOAD;
// // 	R4 = Block_num;
// // 	R2 = [SYSTEM_STATUS_TABLE+1];
// // 	R3 = R0;
// // 	call MOD_4;
// // 	//print R0;
// // 	return;			
	
// // endif;

// // if(R1 == RELEASE_BLOCK) then
// // 	[DISK_FREE_LIST+R2] = [DISK_FREE_LIST+R2]-1;
// // 	return;
// // endif;

// // if(R1 == GET_FREE_BLOCK) then
// // 	alias i R0;
// //  	i = DISK_FREE_AREA;

// //  	while(i < DISK_SWAP_AREA) do    //blocks from 69 to 255 are user blocks
// //  		if([DISK_FREE_LIST + i] == 0) then
// //  			[DISK_FREE_LIST + i] = 1;
// //  			break; 
// //  		endif;
// //  		i = i + 1;
// //  	endwhile;

// //  	if(i == DISK_SWAP_AREA) then
// //  		i = -1;
// //  	endif;

// //  	return;
// // endif;

// // if(R1 == GET_SWAP_BLOCK) then
// // 	//no argument
// // 	alias i R0;
// //  	i = DISK_SWAP_AREA;

// //  	while(i < DISK_SIZE) do    //blocks from 69 to 255 are user blocks
// //  		if([DISK_FREE_LIST + i] == 0) then
// //  			[DISK_FREE_LIST + i] = 1;
// //  			break; 
// //  		endif;
// //  		i = i + 1;
// //  	endwhile;

// //  	if(i == DISK_SIZE) then
// //  		i = -1;
// //  	endif;

// //  	return;
// // endif;


alias functionNum R1;
//Functions 
// GET_FREE_PAGE(1)
// RELEASE_PAGE(2)
// GET_FREE_BLOCK(3)
// RELEASE_BLOCK(4)
// GET_CODE_PAGE(5)
// GET_SWAP_BLOCK (6)

//---FINAL---
//GET_FREE_PAGE = 1 ----- Args - NIL,Ret Free Page Number
// Returns the page number of a free page
// Called by fork and exec system calls. Also called by exception handler on page fault.

if( functionNum == 1 ) then

    //Increment WAIT_MEM_COUNT in system status table
    [SYSTEM_STATUS_TABLE + 3] = [SYSTEM_STATUS_TABLE + 3] + 1;

    //While memory is full (MEM_FREE_COUNT will be 0)---- BUSY LOOP
    while( [SYSTEM_STATUS_TABLE + 2] == 0) do
        [PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1]*16 + 4] = WAIT_MEM;
        //call module 5
        multipush(R1);
        call SCHEDULER;
        multipop(R1);
    endwhile ;

    //Decrement MEM_FREE_COUNT & WAIT_MEM_COUNT in system status table
    [SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] - 1;
    [SYSTEM_STATUS_TABLE + 3] = [SYSTEM_STATUS_TABLE + 3] - 1;

    //Find a free page using memory free list
    alias pageIdx R2;
    pageIdx = 0;
    while( pageIdx < 128 ) do
        if( [MEMORY_FREE_LIST + pageIdx] == 0 ) then
            R0 = pageIdx;
            break;
        endif ;
        pageIdx = pageIdx + 1;
    endwhile ;

    [MEMORY_FREE_LIST + pageIdx] = 1;
    
    return;
endif;



//---FINAL---
//RELEASE_PAGE = 2	----- Args - Page Number, Return NIL
// Decrements the entry corresponding to page in memory free list
// Called by the Free page table and Free UArea Page functions.

if( functionNum == 2 ) then
    alias pageNum R2;
    
    //Decrement the corresponding entry in the memory free list
    [MEMORY_FREE_LIST + pageNum] = [MEMORY_FREE_LIST + pageNum] - 1; 

    //If that entry in the memory free list becomes zero, then the page is free
    if( [MEMORY_FREE_LIST + pageNum] == 0 ) then
            [SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] + 1;
    endif ;

    //STATE field of other process table entries with WAIT_MEM to READY
    alias var R3;
    var = 0;
    while( var < 16 ) do
        if( [PROCESS_TABLE + 16*var + 4] ==  WAIT_MEM) then
            [PROCESS_TABLE + 16*var + 4] = READY;
        endif ;
        var = var + 1;
    endwhile ;

    return;
endif;




//GET_FREE_BLOCK = 3 ----- Args - NIL,Ret Free Block Number or -1
// Returns the block number of a free disk block. Returns -1 if disk is full.

if( functionNum == 3 ) then

    // loop through entries in the Disk Free List from DISK_FREE_AREA to DISK_SWAP_AREA - 1
    // ** User Block, not preallocated to the OS or swap area

    alias blockIndex R2;
    blockIndex = DISK_FREE_AREA;
    while( blockIndex < DISK_SWAP_AREA - 1 ) do
        if( [DISK_FREE_LIST + blockIndex] == 0 ) then
            [DISK_FREE_LIST + blockIndex] = 1;
            R0 = blockIndex;
            break;
        endif ;
        blockIndex = blockIndex + 1;
    endwhile ;
    
    return;
endif;




//---FINAL---
//---RELEASE_BLOCK = 4 ----- Args - Block Number, PID--- Return NIL
// Decrements the entry corresponding to the disk block in the disk free list

if( functionNum == 4 ) then
    alias codeBlock R2;
    alias currentPID R3;
    [DISK_FREE_LIST + codeBlock] = [DISK_FREE_LIST + codeBlock] - 1;
    return;
endif;




// //---FINAL---
// //-----GET_CODE_PAGE = 5 ----- Args - Block Number, Return Page Number
// // Loads a single code page to memory given the block number of the page in the disk

// if( functionNum == 5 ) then
//     alias codeBlock R8;
//     codeBlock = R2;
//     print "block1"; print R2; print codeBlock;
//     alias pid R3;
//     pid = 0;
//     alias diskMapTable R4;
//     alias cnt R5;
//     alias pageTable R6;
//     alias pageNo R7;
//     //alias auxInfo R8;
    
//     while( pid < 16 ) do
//         diskMapTable = DISK_MAP_TABLE + 10*pid;
//         pageTable = PAGE_TABLE_BASE + 20*pid + 8;
//         cnt = 0;
//         while(cnt < 4) do
//             //auxInfo = [pageTable + cnt*2 + 1 ];
//             if( [diskMapTable + 4 + cnt] == codeBlock &&  [pageTable + cnt*2 ] != -1) then
//                 //Increment entry in the memory free list
//                 pageNo = [pageTable + cnt*2 ];
//                 [MEMORY_FREE_LIST + pageNo] = [MEMORY_FREE_LIST + pageNo] + 1; 

//                 //return page number
//                 R0 = pageNo;
//                 return;
//             endif ;
//             cnt = cnt + 1;
//         endwhile;
//         pid = pid + 1;
//     endwhile ;
//     print "b1";
//     //---code page is not in memory----has to be loaded from disk 
//     //---Get Free Page function (memory manager) to allocate a new page.
//     multipush(R8);
//     R1 = GET_FREE_PAGE;
//     call MEMORY_MANAGER;
//     multipop(R8);
//     pageNo = R0;
//             print "block2"; print codeBlock;
//      //Calling Disk load function 2 in device manager module (module 4)
//     multipush(R7, R8); 
//     R1 = DISK_LOAD;
//     R2 = [SYSTEM_STATUS_TABLE + 1];
//     R3 = pageNo;
//     R4 = codeBlock; 
//     call DEVICE_MANAGER; 
//     multipop(R7, R8);
//     R0 = R0;
//     print "jhii";
//     return;
// endif;


//---FINAL---
//-----GET_CODE_PAGE = 5 ----- Args - Block Number, Return Page Number
// Loads a single code page to memory given the block number of the page in the disk

if( functionNum == 5 ) then
    alias codeBlock R2;

    alias pid R3;
    pid = 0;
    alias diskMapTable R4;
    alias cnt R5;
    alias pageTable R6;
    alias pageNo R7;
    alias auxInfo R8;
    
    while( pid < 16 ) do
        diskMapTable = DISK_MAP_TABLE + 10*pid;
        pageTable = PAGE_TABLE_BASE + 20*pid + 8;
        cnt = 0;
        while(cnt < 4) do
            auxInfo = [pageTable + cnt*2 + 1 ];
            if( [diskMapTable + 4 + cnt] == codeBlock && (auxInfo == "0100" || auxInfo == "1100") ) then
                //Increment entry in the memory free list
                pageNo = [pageTable + cnt*2 ];
                [MEMORY_FREE_LIST + pageNo] = [MEMORY_FREE_LIST + pageNo] + 1; 

                //return page number
                R0 = pageNo;
                return;
            endif ;
            cnt = cnt + 1;
        endwhile;
        pid = pid + 1;
    endwhile ;
    
    //---code page is not in memory----has to be loaded from disk 
    //---Get Free Page function (memory manager) to allocate a new page.
    multipush(R1, R2);
    R1 = 1;
    call MOD_2;
    multipop(R1, R2);
    
     //Calling Disk load function 2 in device manager module (module 4)
    multipush(R0, R1, R2); 
    R4 = codeBlock; 
    R3 = R0;
    R2 = [SYSTEM_STATUS_TABLE + 1];
    R1 = 2;
    call MOD_4; 
    multipop(R0, R1, R2);
    R0 = R0;
    breakpoint;
    return;
endif;


//GET_SWAP_BLOCK = 6 ----- Args - NIL,Ret Block Number
// Returns the block number of a free disk block in the swap area

if( functionNum == 6 ) then

    // loop through entries in the Disk Free List from DISK_FREE_AREA to DISK_SWAP_AREA - 1
    // ** User Block, not preallocated to the OS or swap area

    alias blockIndex R2;
    blockIndex = DISK_SWAP_AREA;
    while( blockIndex < DISK_SIZE - 1 ) do
        if( [DISK_FREE_LIST + blockIndex] == 0 ) then
            [DISK_FREE_LIST + blockIndex] = 1;
            R0 = blockIndex;
            break;
        endif ;
        blockIndex = blockIndex + 1;
    endwhile ;
    
    return;
endif;
