// //----  FORK SYCALL  --------------------------------------------------------
// // assig: Kernel Mode Switch cnt
// [70*512 + 511] = [70*512 + 511] + 1; 

// //----  Set MODE Flag and Switch Stack ------------------------
// alias userSP R1;
// userSP = SP; 
// [PROCESS_TABLE+[SYSTEM_STATUS_TABLE+1]*16+9] = 8;
// [PROCESS_TABLE+[SYSTEM_STATUS_TABLE+1]*16+13] = SP;
// SP = [PROCESS_TABLE+[SYSTEM_STATUS_TABLE+1]*16+11]*512-1;

// alias childPID R2;
// alias cnt R4;
// alias parentPTBR R5;
// parentPTBR = PTBR;

// // ---- Call Get PCB Entry (Process Manager) ---------------- 
// // Args: funNum = 1, no Args
// // returns a new PID for childPID by looking through Process Table
// multipush(R1, R2, R5);
// R1 = 1;
// call MOD_1;
// multipop(R1, R2, R5);
// childPID = R0;

// // ---- If no space for new Process, (limit is 16) ----------------  
// if(childPID == -1) then
//     print("ForkExit!");
//     alias physicalAddrRetVal R3;
//     physicalAddrRetVal = [parentPTBR + 2 * (userSP-1)/512] * 512 + ((userSP-1)%512);
//     [physicalAddrRetVal] = -1;
//     [PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 0;
//     SP = userSP;
//     ireturn;
// endif;

// // ---- Allocate the Heap for Parent, Get Free Page --------------------
// if([parentPTBR + 4] == -1 || [parentPTBR + 5] == "0000") then
//     multipush(R1, R2, R3, R4, R5);
//     R1 = 1;
//     call MOD_2;
//     multipop(R1, R2, R3, R4, R5);
//     [parentPTBR + 4] = R0;
//     [parentPTBR + 5] = "0110";
//     multipush(R1, R2, R3, R4, R5);
//     R1 = 1;
//     call MOD_2;
//     [parentPTBR + 6] = R0;
//     [parentPTBR + 7] = "0110";
//     multipop(R1, R2, R3,R4, R5);
// endif;

// // ---- Stack for Child Process, calling Get Free Page function ------------
// alias childPTBR R3;
// childPTBR = PAGE_TABLE_BASE + childPID * 20;

// // Aux Info Same as Parent's
// multipush(R1,R2,R3,R4,R5);
// R1 = 1;
// call MOD_2;
// [childPTBR + 16] = R0;
// [childPTBR + 17] = [parentPTBR + 17];
// multipop(R1, R2, R3, R4, R5);
// multipush(R1, R2, R3, R4, R5);
// R1 = 1;
// call MOD_2;
// [childPTBR + 18] = R0;
// [childPTBR + 19] = [parentPTBR + 19];
// multipop(R1,R2,R3,R4,R5);

// // ---- UArea Page for Child Process, Get Free Page again
// // Store it in Process Table 11th offset
// alias UAreaPage R7;
// multipush(R1, R2, R3,R4, R5);
// R1 = 1;
// call MOD_2;
// UAreaPage = R0;
// [PROCESS_TABLE + childPID * 16 + 11] = R0;
// multipop(R1, R2, R3,R4, R5);

// alias parentProcessEntry R10;
// alias childProcessEntry R11;
// parentProcessEntry = PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16;
// childProcessEntry = PROCESS_TABLE + childPID * 16;

// // ---- Process Table for Child Process ----------------------------------------
// //---- userId 
// [childProcessEntry + 3] = [parentProcessEntry + 3];
// //---- Swap Flag
// [childProcessEntry + 6] = [parentProcessEntry + 6];
// //---- UserArea Swap Status
// [childProcessEntry + 10] = [parentProcessEntry + 10];
// //---- Inode Index
// [childProcessEntry + 7] = [parentProcessEntry + 7];
// //---- UPTR
// [childProcessEntry + 13] = [parentProcessEntry + 13];
// //---- Mode Flag
// [childProcessEntry + 9] = 0;
// //---- KPTR
// [childProcessEntry + 12] = 0;
// //---- Tick
// [childProcessEntry + 0] = 0;
// //---- PPID
// [childProcessEntry + 2] = [SYSTEM_STATUS_TABLE + 1];
// //---- STATE
// [childProcessEntry + 4] = CREATED;

// // ----- PER-PROCESS RESOURCE TABLE -- CHILD ---------------
// cnt = 0;
// alias resourceTable R15;
// resourceTable = [PROCESS_TABLE + childPID*16 + 11]*512 + 496;
// while( cnt < 16 ) do
//     [resourceTable + cnt] = [ [PROCESS_TABLE+[SYSTEM_STATUS_TABLE+1]*16+11] * 512 + 496 + cnt];
//     // If the resource is a File (check the Resource Identifier field in the per-process resource table)
//     // using the open file table index, 
//     // increment the OPEN INSTANCE COUNT field in the open file table entry.
//     if(cnt%2 == 0 && [resourceTable + cnt]==FILE) then
//         [OPEN_FILE_TABLE +[resourceTable + cnt + 1]*4 + 1] = [OPEN_FILE_TABLE +[resourceTable + cnt + 1]*4 + 1] + 1;
//     endif;
//     // If the resource is semaphore (check the Resource Identifier field in the per-process resource table)
//     // using the sempahore table index, 
//     // increment the PROCESS COUNT field in the semaphore table entry
//     if( cnt%2 == 0 &&  [resourceTable + cnt]==1 ) then
//         [SEMAPHORE_TABLE + [resourceTable + cnt + 1]*4 + 1] = [SEMAPHORE_TABLE + [resourceTable + cnt + 1]*4 + 1] + 1;
//     endif ;
//     cnt = cnt + 1;
// endwhile ;

// // ---- Per Process Disk Map Table for Child Process Copy from Parent --------------
// cnt = 0;
// while( cnt < 10) do
//     [DISK_MAP_TABLE + childPID * 10 + cnt] = [DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1] * 10 + cnt];
//     cnt = cnt + 1;
// endwhile;

// // ---- PAGE TABLE FOR CHILD PROCESS ---------------------------
// childPTBR = PAGE_TABLE_BASE + childPID * 20;
// // Library, Heap and Code copy from Parent, Stack has been Already set up above
// // If any of them shared, increment Mem_Free_List entry for it
// cnt = 0;
// while(cnt < 16) do
// 	[childPTBR + cnt] = [parentPTBR + cnt];
// 	if( cnt%2 == 0 && [childPTBR + cnt] != -1 ) then
// 		[MEMORY_FREE_LIST + [childPTBR + cnt]] = [MEMORY_FREE_LIST + [childPTBR + cnt]] + 1;
// 	endif;
// 	cnt = cnt + 1;
// endwhile;

// // ----- Copy Contents of User Stack Pages of Parent to Child, word-by-word --------
// // ---- Two Pages to Copy, 512 (Pg.8) + 512 (Pg.9) -----
// cnt = 0;
// while(cnt < 512) do
// 	[[childPTBR + 16]*512 + cnt] = [[parentPTBR + 16] * 512 + cnt];
// 	[[childPTBR + 18]*512 + cnt] = [[parentPTBR + 18] * 512 + cnt];
// 	cnt = cnt + 1;
// endwhile;

// //----- BP placed in start of Kernel Stack of Child Process --------------------
// [UAreaPage*512] = BP; 


// //---- Set Up the Return Values in Parent and Child --------------------------
// alias physicalAddrRetVal R9;

// // Parent
// physicalAddrRetVal = [parentPTBR + 2 * (userSP-1)/512] * 512 + ((userSP-1)%512);
// [physicalAddrRetVal] = childPID;

// // Child
// physicalAddrRetVal = [childPTBR + 2 * (userSP-1)/512] * 512 + ((userSP-1)%512);
// [physicalAddrRetVal] = 0;

// // Mode Flag Parent Reset, Returning is to Parent, child will have to be scheduled
// [PROCESS_TABLE + [SYSTEM_STATUS_TABLE+1] * 16 + 9] = 0;
// SP = userSP;
// ireturn;
// FORK SYSTEM CALL

//Mode
[PROCESS_TABLE + [SYSTEM_STATUS_TABLE+1]*16 + 9] = 8;
alias userSP R5;
userSP = SP;


alias processEntryP R14;
processEntryP = PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1]*16;

//--Switch Stack
//save user SP, set SP to KPTR
[processEntryP + 13] = SP;
SP = [processEntryP + 11]*512 - 1;

//GET_PCB_ENTRY, PROCESS MANAGER
multipush(R5, R14);
R1 = 1;
call MOD_1;
multipop(R5, R14);

//save PID of child
alias chPID R6; 
chPID = R0;

if( chPID == -1 ) then
    //---16 Processes already running
    //store -1 return value at userSP - 1
    alias physicalAddrRetVal R15;
    physicalAddrRetVal = ([PTBR + 2 * ((userSP-1)/512)] * 512) + ((userSP-1)%512);
    [physicalAddrRetVal] = -1;

    //switch stack, mode
    goto end;
endif ;



//ELSE
//6 10 9 12

[processEntryP+14] = PTBR;
alias chPTBR R7;
chPTBR = PAGE_TABLE_BASE + chPID*20;
alias pPTBR R8;
pPTBR = PAGE_TABLE_BASE + [SYSTEM_STATUS_TABLE+1]*20;



//parent & child share same HEAP. if heap pages were not allocated for the parent , allocate it now.
if( [pPTBR + 4] == -1 || [pPTBR+5] == "0000") then
    // GET_FREE_PAGE, MEMORY MANAGER
    multipush(R5, R6, R7, R8, R14);
    R1=1;
    call MOD_2;
    multipop(R5, R6, R7, R8, R14);
    [ pPTBR + 4]=R0;
    [ pPTBR + 5]="0110";

    multipush(R5, R6, R7, R8, R14);
    R1=1;
    call MOD_2;
    multipop(R5, R6, R7, R8, R14);
    [ pPTBR + 6]=R0;
    [ pPTBR + 7]="0110";
endif ;

//--Allocate 2 STACK AND USER AREA PAGE
//GET_FREE_PAGE, MEMORY MANAGER
multipush(R5, R6, R7, R8, R14);
R1=1;
call MOD_2;
multipop(R5, R6, R7, R8, R14);
[chPTBR + 16] = R0;
[chPTBR + 17] = [pPTBR + 17];

multipush(R5, R6, R7, R8, R14);
R1=1;
call MOD_2;
multipop(R5, R6, R7, R8, R14);
[chPTBR + 18] = R0;
[chPTBR + 19] = [pPTBR + 19];


multipush(R5, R6, R7, R8, R14);
R1=1;
call MOD_2;
multipop(R5, R6, R7, R8, R14);
[PROCESS_TABLE + chPID*16 + 11] = R0;

alias processEntryC R13;
processEntryC = PROCESS_TABLE + chPID*16;

//PROCESS TABLE -- CHILD

//Copy PARENT's Process Table Entry to child 
//USERID, SWAP FLAG, USER AREA SWAP STATUS, INODE INDEX, UPTR 
[processEntryC + 3] = [processEntryP + 3];
[processEntryC + 6] = [processEntryP + 6];
[processEntryC + 10] = [processEntryP + 10];
[processEntryC + 7] = [processEntryP + 7];
[processEntryC + 13] = [processEntryP + 13];

//TICK, MODE FLAG, KPTR = 0
[processEntryC + 0] = 0;
[processEntryC + 9] = 0;
[processEntryC + 12] = 0;


//PPID, STATE, USER AREA PAGE NUMBER
[processEntryC + 2] = [SYSTEM_STATUS_TABLE + 1];
[processEntryC + 4] = CREATED;
//[PROCESS_TABLE + chPID*16 + 11] = ua;

//PID, PTBR, PTLR already initialized Get Pcb Entry function
//no need to initialize INPUT BUFFER.


//PER-PROCESS RESOURCE TABLE -- CHILD
alias cnt R9;
cnt = 0;
alias resourceTable R15;
resourceTable = [PROCESS_TABLE + chPID*16 + 11]*512 + 496;
while( cnt < 16 ) do
    [resourceTable + cnt] = [ [PROCESS_TABLE+[SYSTEM_STATUS_TABLE+1]*16+11] * 512 + 496 + cnt];

    //If resource is semaphore (check Resource Identifier field in per-process resource table)
    //using sempahore table index, 
    //increment PROCESS COUNT field in semaphore table entry
    if( cnt%2 == 0 &&  [resourceTable + cnt]==1 ) then
        [SEMAPHORE_TABLE + [resourceTable + cnt + 1]*4 + 1] = [SEMAPHORE_TABLE + [resourceTable + cnt + 1]*4 + 1] + 1;
    endif ;

    // If the resource is a file
    // using open file table index, increment OPEN INSTANCE COUNT field in open file table entry.
    if( cnt%2 == 0 &&  [resourceTable + cnt]==0 ) then
        [OPEN_FILE_TABLE + [resourceTable + cnt + 1]*4 + 1] = [OPEN_FILE_TABLE + [resourceTable + cnt + 1]*4 + 1] + 1;
    endif ;
    
    cnt = cnt + 1;
endwhile ;



//DISK_MAP_TABLE -- CHILD

alias diskMapTable R10;
diskMapTable = DISK_MAP_TABLE + 10*chPID;
cnt = 0;
while( cnt < 10 ) do
    [ diskMapTable + cnt ] = [DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE+1] * 10 + cnt];
    cnt = cnt + 1;
endwhile ;


//PAGE_TABLE -- CHILD

cnt = 0;
while( cnt < 8 ) do
    [chPTBR + cnt*2] = [pPTBR + cnt*2];
    [chPTBR + cnt*2 +1] = [pPTBR + cnt*2 +1];
    [MEMORY_FREE_LIST + [chPTBR + cnt*2]] = [MEMORY_FREE_LIST + [chPTBR + cnt*2]] + 1;
    cnt = cnt + 1;
endwhile ;


//Copy word by word the contents of the parent user stack to that of the child.
cnt = 0;
while( cnt < 512 ) do
    [[chPTBR + 16]*512 + cnt] = [[pPTBR + 16]*512 + cnt];
    [[chPTBR + 18]*512 + cnt] = [[pPTBR + 18]*512 + cnt];
    cnt = cnt + 1;
endwhile ;


//Store the value in the BP register on top of the kernel stack of child process. 
//This value will be used to initialize the BP register of the child process by the scheduler when the child is scheduled for the first time.
[[processEntryC + 11]*512] = BP;


//---Store return value at userSP - 1
//PARENT : Child PID
//CHILD : 0
alias physicalAddrRetVal R15;
physicalAddrRetVal = ([pPTBR + 2*((userSP-1)/512)] * 512) + ((userSP-1)%512);
[physicalAddrRetVal] = chPID;
physicalAddrRetVal = ([chPTBR + 2*((userSP-1)/512)] * 512) + ((userSP-1)%512);
[physicalAddrRetVal] = 0;
end:
//switch stack, mode
SP = userSP; 
[processEntryP + 9] = 0;
ireturn;
